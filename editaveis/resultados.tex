\chapter[Resultados]{Resultados}

Este capítulo mostrará os resultados obtidos durante a execução deste trabalho, os requisitos finalizados, métricas de código obtidas e algumas telas da aplicação desenvolvida.


\section{Requisitos}

Esta seção descreve os requisitos obtidos para o desenvolvimento da ferramenta. Estes requisitos foram obtidos a partir da análise de funcionalidades em comum entre as ferramentas e reunião com a STI. Todos estes requisitos foram validados e priorizados com a STI, de acordo com suas necessidades e expectativas acerca da ferramenta.

\subsection{Requisitos Extraídos a Partir do Estudo das Ferramentas}

A análise das ferramentas presentes no mercado possibilitou com que uma interseção entre os requisitos elicitados fosse feita. Seguem abaixo as \textit{features} levantadas a partir desta interseção:

\begin{itemize}

\item Inserção, exclusão, edição e visualização de perfil de usuário;

\item Inserção, exclusão, edição e visualização de organizações detentoras de
projetos de desenvolvimento de software;

\item Inserção, exclusão, edição e visualização de projetos de desenvolvimento de software;

\item Gerenciamento de múltiplos projetos por organização;

\item Criação de contagem de pontos de função para os softwares registrados;

\item Geração de relatórios em pdf;

\item Medição de esforço necessário para desenvolvimento de features;

\item Visualização gráfica de atributos como tamanho total ao longo do tempo e
esforço;

\item Criação e gerenciamento de Baselines;

\item \textit{Tracking} acerca de mudanças nas contagens, como o autor da modificação e data da mesma.

\end{itemize}

\subsection{Requisitos Extraídos a Partir de Reunião com a STI}

Além dos requisitos elicitados a partir do estudo das ferramentas, outros requisitos foram elicitados por meio de reunião com a STI. Nesta reunião foram abordadas necessidades específicas dos órgãos públicos brasileiros, e alguns esclarecimentos acerca dos requisitos não funcionais da ferramenta.

Os requisitos funcionais obtidos foram:

\begin{itemize}

  \item Gerenciamento e controle de acesso de usuários,

  \item Busca por projetos, organizações  dados específicos de preenchimento
  como funções de transação ou de dados;

  \item Valor de ponto de função pro projeto;

  \item Base histórica de contagem;

  \item Gastos totais por projeto e órgão;

  \item Possibilitar contagens estimadas e detalhadas.

\end{itemize}

Requisitos não-funcionais também foram obtidos a partir desta reunião:

\begin{itemize}

  \item Tratamento de fluxo de dados, devido sua grande quantidade. Com múltiplos órgãos fazendo requisições simultâneas ao servidor, o desenvolvimento de uma API mostra-se mais adequado;

  \item Questões de segurança como encriptação de dados, autenticação de usuários e bloqueio de acesso externo à aplicação;

  \item Desenvolvimento de formulários dinâmicos para preenchimento das informações acerca das contagens, facilitando a aceitação dos usuários ao sistema;

  \item Disponibilidade da aplicação para múltiplos sistemas operacionais

\end{itemize}

\section{Definição de Ferramentas}

Esta seção apresenta uma explicação sucinta de cada ferramenta utilizada para o desenvolvimento do projeto, assim como, quando necessário, o motivo de suas escolhas. A figura \ref{fig18} ilustra todas as ferramentas a serem utilizadas no presente trabalho.

\begin{figure}[H]
	\centering
	\includegraphics[keepaspectratio=true,scale=0.3]{figuras/fig18.eps}
	\caption{Ferramentas Escolhidas para o Desevolvimento}
	\label{fig18}
\end{figure}

\begin{itemize}

  \item \textbf{Ruby on Rails:} \textit{Framework} de desenvolvimento de aplicações web por meio da linguagem de programação Ruby. Sua arquitetura se baseia em MVC (\textit{Model, View e Controller}) e será utilizada em modo API(\textit{Application Programming Interface}), ou seja, será construída para que forneça um serviço a outra aplicação. Os dados serão disponibilizados via JSON(\textit{JavaScript Object Notation}). A criação de uma API se deve ao fato de que um dos requisitos não funcionais da aplicação é o grande fluxo de dados. O framework também será utilizado para o desenvolvimento de uma aplicação \textit{fullstack}.

  \item \textbf{Gitlab:} Provê controle de versão, revisão de código, \textit{tracking} de \textit{issues} além de espaço para a criação de uma wiki do projeto.

  \item \textbf{PostgresSQL:} Sistema gerenciador de banco de dados objeto relacional de código aberto.

  \item \textbf{RubyCritic:} Ferramenta para análise estática de código fonte, além de métricas como duplicação de código e complexidade ciclomática. Possui integração com o repositório do aplicação.

	\item \textbf{Gitlab CI:} Ferramenta para integração contínua de código. Quando um \textit{commit} for integrado ao repositório da aplicação, a ferramenta criará uma máquina virtual, com configurações pré determinadas pelo desenvolvedor, para execução de testes unitários e de integração. Caso a \textit{build} falhe, o Gitlab CI impede que o \textit{commit} ou \textit{merge} seja integrado a \textit{branch}.

	\item \textbf{SimpleCov:} SimpleCov é uma ferramenta de análise de cobertura de testes. A partir dela poderá ser obtida uma análise da cobertura de código fonte.

\end{itemize}

\section{Status Final de Desenvolvimento}

Ao final do desenvolvimento das \textit{sprints}, uma aplicação estável foi desenvolvida a partir do backlog delimitado no início do projeto. Algumas funcionalidades tiveram sua implementação concluída, outras tiveram implementação parcial e algumas não foram implementadas. O escopo inicial do trabalho era grande e algumas dificuldades impediram a conclusão de todas as histórias propostas. Um detalhamento maior dessas questões será tratado no capítulo de conclusão.

Abaixo as histórias descritas no backlog e seu status final de desenvolvimento:

\begin{table}[h]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{História}                 & \textbf{Status}                     \\ \hline
CRUD Organizações                 & Finalizado                          \\ \hline
CRUD Projetos                     & Finalizado                          \\ \hline
CRUD Usuário                      & Finalizado                          \\ \hline
CRUD Funções de Dados             & Finalizado                          \\ \hline
CRUD Funções de Transação         & Finalizado                          \\ \hline
Integração contínua               & Finalizado                          \\ \hline
Perfis de Usuário                 & Parcialmente                        \\ \hline
Gráficos de evolução de contagens & Finalizado                          \\ \hline
Criação de Baselines              & Parcialmente                        \\ \hline
Histórico de contagens            & Finalizado                          \\ \hline
Custo de projetos                 & Parcilamente                        \\ \hline
Login de Usuário                  & Finalizado                           \\ \hline
Relatório                         & \multicolumn{1}{l|}{Não finalizado} \\ \hline
\end{tabular}
\caption{Status final do desenvolvimento da aplicação}
\label{status}
\end{table}

\section{Visão de Produto}

O resultado do desenvolvimento deste trabalho é um software para contagem de pontos de função. Abaixo uma descrição ao nível de funcionalidades da aplicação:

\begin{itemize}
\item Gerenciamento de contagem de pontos de função, criação, edição e remoção de contagens;
\item Histórico de contagens e visualização detalhada de cada uma das mesmas;
\item Visão geral de um projeto e as contagens associadas ao mesmo;
\item Controle de acesso de usuários via login;
\item Perfis de usuário para diferentes acessos, onde só certos de tipos de usuário tem permissão para alteração de contagens;
\item Cálculo de custos de projeto a partir do valor de ponto de função definido em cada contagem;
\item Gráfico de evolução de contagens de desenvolvimento;
\item Definição de uma contagem como baseline do projeto;
\end{itemize}

\subsection{API}

Além da aplicação também foi desenvolvida uma API para a mesma. A partir da API outros desenvolvedores poderão colaborar desenvolvendo um front-end desacoplado para a aplicação, apenas consumindo os dados da API.


\section{Métricas de Código}

Para a coleta de métricas de código do projeto foi usada a ferramenta Rubycritic. O objeto da mesma é dar uma nota a aplicação com base em algumas métricas de código coletadas. A nota se baseia em três métricas conhecidas pela comunidade Ruby:

\begin{itemize}
  \item \textbf{Reek:} Esta métrica analisa Code Smells no código fonte. Smells são indicadores de onde o código pode estar difícil de se manter, evoluir ou simplesmente ser lido. Alguns destes indicadores são: tamanho de classe, variáveis não utilizadas, iteradores aninhados entre muitas outras. Uma descrição mais profunda dos indicadores pode ser encontrada em \url{https://github.com/troessner/reek/blob/master/docs/Code-Smells.md}

  \item \textbf{Flay:} Métrica que analisa duplicações de código. A forma de análise não se baseia em duplicações puras, mas na estrutura do código. Variáveis, nome de classes e métodos e espaços em branco são ignorados neste caso.

  \item \textbf{Flog:} Esta métrica analisa a complexidade ABC do código. Esta complexidade analisa definição de variáveis, fluxo de execuções e chamadas de métodos, atribuindo uma pontuação. Quanto maior a pontuação dada, maior é a complexidade do código e maior será o esforço para testá-lo.

\end{itemize}

A figura abaixo mostra a análise feita pela ferramenta e a nota atribuída ao projeto:

\begin{figure}[]
	\centering
	\includegraphics[keepaspectratio=true,scale=0.3]{figuras/fig12.eps}
	\caption{Análise de Código}
	\label{fig12}
\end{figure}

A nota atribuída a aplicação foi de 70 pontos. Uma boa nota se observamos o curto período de desenvolvimento e o pouco tempo para refatoração de código. O principal problema apontado foi a complexidade de algumas controladores, como a de funções de transação e a de projetos.

\section{Cobertura de Código}

A cobertura de código foi analisada pela gem \textit{Simplecov}. Em resumo, a ferramenta analisa todos os testes criados e quantas linhas relevantes de código foram cobertas pelos testes escritos.

A figura abaixo apresenta o \textit{report} dado pela ferramenta:

\begin{figure}[H]
	\centering
	\includegraphics[keepaspectratio=true,scale=0.3]{figuras/fig13.eps}
	\caption{Cobertura de Código}
	\label{fig13}
\end{figure}

A cobertura de código chegou a 75\%. Os métodos de contagem das modelos e controladores foram responsáveis pela queda de cobertura. Ainda continua sendo um bom valor para  o resultado final do projeto.

\section{Repositórios}

Abaixo os links para os dois repositórios utilizados neste trabalho, o primeiro sendo da API e o segundo da aplicação web:

\begin{itemize}
  \item \url{https://gitlab.com/danielhmarinho/function-points-api}
	\item \url{https://gitlab.com/danielhmarinho/function-points-web}
\end{itemize}

O primeiro repositório armazena a API, a partir dele novas implementações de interface poderão ser feitas. O segundo repositório diz respeito a aplicação \textit{fullstack}, ela será executada apenas na parte do servidor.
